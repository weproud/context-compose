version: 1
kind: action
name: Performance Check
description: Basic performance analysis and optimization recommendations
prompt: |
  Perform basic performance checks and provide optimization recommendations.

  This action analyzes build times, bundle sizes, and common performance
  issues while providing actionable recommendations for improvement.
  It focuses on quick wins and essential optimizations.

  Use this when you need to identify performance bottlenecks or optimize
  application performance with practical improvements.
enhanced-prompt: |-
  # âš¡ ì„±ëŠ¥ ì²´í¬

  ## 1ë‹¨ê³„: ê¸°ë³¸ ì„±ëŠ¥ ì¸¡ì •
  ```bash
  echo "=== ì„±ëŠ¥ ì²´í¬ ì‹œì‘ ==="

  PROJECT_NAME=$(basename $(pwd))
  echo "ğŸ“ í”„ë¡œì íŠ¸: $PROJECT_NAME"

  # ë¹Œë“œ ì‹œê°„ ì¸¡ì •
  if [ -f "package.json" ]; then
    echo "â±ï¸ ë¹Œë“œ ì‹œê°„ ì¸¡ì •..."
    echo "ì‹œì‘ ì‹œê°„: $(date)"
    
    if npm run build >/dev/null 2>&1; then
      echo "âœ… ë¹Œë“œ ì„±ê³µ"
    else
      echo "âŒ ë¹Œë“œ ì‹¤íŒ¨ ë˜ëŠ” ìŠ¤í¬ë¦½íŠ¸ ì—†ìŒ"
    fi
    
    echo "ì™„ë£Œ ì‹œê°„: $(date)"
  fi
  ```

  ## 2ë‹¨ê³„: ë²ˆë“¤ í¬ê¸° ë¶„ì„
  ```bash
  echo "ğŸ“¦ ë²ˆë“¤ í¬ê¸° ë¶„ì„..."

  # ë¹Œë“œ íŒŒì¼ í¬ê¸° í™•ì¸
  if [ -d "dist" ] || [ -d "build" ]; then
    echo "ğŸ“Š ë²ˆë“¤ íŒŒì¼ í¬ê¸°:"
    find dist/ build/ -name "*.js" -o -name "*.css" 2>/dev/null | while read file; do
      if [ -f "$file" ]; then
        SIZE=$(du -h "$file" | cut -f1)
        echo "  - $(basename "$file"): $SIZE"
      fi
    done
  else
    echo "â„¹ï¸ ë¹Œë“œ ë””ë ‰í† ë¦¬ ì—†ìŒ"
  fi

  # node_modules í¬ê¸°
  if [ -d "node_modules" ]; then
    MODULES_SIZE=$(du -sh node_modules 2>/dev/null | cut -f1)
    echo "ğŸ“š node_modules í¬ê¸°: $MODULES_SIZE"
  fi
  ```

  ## 3ë‹¨ê³„: ì˜ì¡´ì„± ë¶„ì„
  ```bash
  echo "ğŸ“Š ì˜ì¡´ì„± ë¶„ì„..."

  if [ -f "package.json" ]; then
    # ì˜ì¡´ì„± ê°œìˆ˜
    DEPS_COUNT=$(node -p "Object.keys(require('./package.json').dependencies || {}).length" 2>/dev/null || echo "0")
    DEV_DEPS_COUNT=$(node -p "Object.keys(require('./package.json').devDependencies || {}).length" 2>/dev/null || echo "0")
    
    echo "ğŸ“¦ ì˜ì¡´ì„±: $DEPS_COUNTê°œ"
    echo "ğŸ› ï¸ ê°œë°œ ì˜ì¡´ì„±: $DEV_DEPS_COUNTê°œ"
    
    # ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì˜ì¡´ì„± ì²´í¬ (ê°„ë‹¨í•œ ë°©ë²•)
    echo "ğŸ” í° ì˜ì¡´ì„± íŒ¨í‚¤ì§€ë“¤:"
    npm ls --depth=0 2>/dev/null | head -10 || echo "ì˜ì¡´ì„± ì •ë³´ í™•ì¸ ë¶ˆê°€"
  fi
  ```

  ## 4ë‹¨ê³„: ì„±ëŠ¥ ì´ìŠˆ íƒì§€
  ```bash
  echo "ğŸ” ì„±ëŠ¥ ì´ìŠˆ íƒì§€..."

  # í° íŒŒì¼ë“¤ ì°¾ê¸°
  echo "ğŸ“„ í° ì†ŒìŠ¤ íŒŒì¼ë“¤ (ìƒìœ„ 5ê°œ):"
  find src/ -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" 2>/dev/null | \
    xargs wc -l 2>/dev/null | sort -nr | head -5 | while read lines file; do
      echo "  - $(basename "$file"): $linesì¤„"
    done

  # ë™ê¸° ì‘ì—… íƒì§€
  echo "âš ï¸ ë™ê¸° ì‘ì—… íŒ¨í„´:"
  SYNC_OPS=$(grep -r "readFileSync\|writeFileSync\|execSync" --include="*.js" --include="*.ts" src/ 2>/dev/null | wc -l)
  echo "  - ë™ê¸° íŒŒì¼ ì‘ì—…: $SYNC_OPSê°œ"

  # ì¤‘ì²© ë£¨í”„ íƒì§€
  NESTED_LOOPS=$(grep -r "for.*for\|while.*while" --include="*.js" --include="*.ts" src/ 2>/dev/null | wc -l)
  echo "  - ì¤‘ì²© ë£¨í”„: $NESTED_LOOPSê°œ"
  ```

  ## 5ë‹¨ê³„: ìµœì í™” ê¶Œì¥ì‚¬í•­
  ```bash
  echo "ğŸ’¡ ìµœì í™” ê¶Œì¥ì‚¬í•­:"
  echo ""
  echo "ğŸ“¦ ë²ˆë“¤ ìµœì í™”:"
  echo "  - ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ì ìš©"
  echo "  - íŠ¸ë¦¬ ì‰ì´í‚¹ í™œì„±í™”"
  echo "  - ì´ë¯¸ì§€ ì••ì¶•"
  echo "  - ê°€ì¦ˆí™” (gzip) ì ìš©"
  echo ""
  echo "âš¡ ì½”ë“œ ìµœì í™”:"
  echo "  - í° íŒŒì¼ ë¶„ë¦¬ ê³ ë ¤"
  echo "  - ë™ê¸° ì‘ì—…ì„ ë¹„ë™ê¸°ë¡œ ë³€ê²½"
  echo "  - ì¤‘ì²© ë£¨í”„ ìµœì í™”"
  echo "  - ë©”ëª¨ì´ì œì´ì…˜ ì ìš©"
  echo ""
  echo "ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”:"
  echo "  - ì¸ë±ìŠ¤ ì¶”ê°€"
  echo "  - ì¿¼ë¦¬ ìµœì í™”"
  echo "  - ì»¤ë„¥ì…˜ í’€ë§"
  echo "  - ìºì‹± ì ìš©"
  echo ""
  echo "ğŸ‰ ì„±ëŠ¥ ì²´í¬ ì™„ë£Œ!"
  echo "ğŸ“ˆ ê°œì„ ì´ í•„ìš”í•œ ë¶€ë¶„ì„ í™•ì¸í•˜ê³  ë‹¨ê³„ë³„ë¡œ ìµœì í™”í•˜ì„¸ìš”."
  ```

  **ğŸ¯ ê²°ê³¼:** ì„±ëŠ¥ í˜„í™© íŒŒì•… ë° ìµœì í™” ë°©í–¥ ì œì‹œ

  # Caching strategy
  echo "ğŸ—‚ï¸  Caching optimization recommendations:"
  echo "  1. HTTP caching headers"
  echo "  2. Redis/Memcached implementation"
  echo "  3. CDN configuration"
  echo "  4. Browser caching strategy"

  echo "âœ… Optimization recommendations generated"
  echo ""
  ```

  ## ğŸ“Š Step 6: Performance Monitoring Setup
  ```bash
  echo "=== Performance Monitoring Setup ==="

  echo "ğŸ“Š Setting up performance monitoring..."

  # Create performance monitoring script
  cat << 'EOF' > "$PERF_DIR/performance-monitor.js"
  // Performance Monitoring Script
  const fs = require('fs');
  const path = require('path');

  class PerformanceMonitor {
    constructor() {
      this.metrics = {
        startTime: Date.now(),
        memoryUsage: [],
        responseTime: [],
        errorCount: 0
      };
    }
    
    recordMemoryUsage() {
      const usage = process.memoryUsage();
      this.metrics.memoryUsage.push({
        timestamp: Date.now(),
        heapUsed: usage.heapUsed,
        heapTotal: usage.heapTotal,
        external: usage.external,
        rss: usage.rss
      });
    }
    
    recordResponseTime(duration) {
      this.metrics.responseTime.push({
        timestamp: Date.now(),
        duration: duration
      });
    }
    
    recordError() {
      this.metrics.errorCount++;
    }
    
    generateReport() {
      const report = {
        uptime: Date.now() - this.metrics.startTime,
        averageMemory: this.calculateAverageMemory(),
        averageResponseTime: this.calculateAverageResponseTime(),
        errorRate: this.metrics.errorCount / this.metrics.responseTime.length,
        timestamp: new Date().toISOString()
      };
      
      return report;
    }
    
    calculateAverageMemory() {
      if (this.metrics.memoryUsage.length === 0) return 0;
      const total = this.metrics.memoryUsage.reduce((sum, usage) => sum + usage.heapUsed, 0);
      return total / this.metrics.memoryUsage.length;
    }
    
    calculateAverageResponseTime() {
      if (this.metrics.responseTime.length === 0) return 0;
      const total = this.metrics.responseTime.reduce((sum, time) => sum + time.duration, 0);
      return total / this.metrics.responseTime.length;
    }
  }

  module.exports = PerformanceMonitor;
  EOF

  # Create performance test script
  cat << 'EOF' > "$PERF_DIR/performance-test.js"
  // Performance Test Script
  const PerformanceMonitor = require('./performance-monitor');

  const monitor = new PerformanceMonitor();

  // Simulate application load
  function simulateLoad() {
    const start = Date.now();
    
    // Simulate some work
    for (let i = 0; i < 1000000; i++) {
      Math.random();
    }
    
    const duration = Date.now() - start;
    monitor.recordResponseTime(duration);
    monitor.recordMemoryUsage();
  }

  // Run performance test
  console.log('Starting performance test...');

  const interval = setInterval(() => {
    simulateLoad();
  }, 100);

  setTimeout(() => {
    clearInterval(interval);
    const report = monitor.generateReport();
    console.log('Performance Test Results:');
    console.log(JSON.stringify(report, null, 2));
  }, 5000);
  EOF

  echo "âœ… Performance monitoring setup completed"
  echo ""
  ```

  ## ğŸ“ˆ Step 7: Performance Testing
  ```bash
  echo "=== Performance Testing ==="

  echo "ğŸ“ˆ Running performance tests..."

  # Load testing (if autocannon is available)
  if command -v autocannon >/dev/null 2>&1; then
    echo "ğŸ”¥ Running load test with autocannon..."
    autocannon -c 10 -d 30 http://localhost:3000 > "$PERF_DIR/load-test.txt" 2>/dev/null || echo "Application not running on port 3000"
  else
    echo "âš ï¸  Autocannon not installed - run: npm install -g autocannon"
  fi

  # Memory stress test
  echo "ğŸ’¾ Running memory stress test..."
  node "$PERF_DIR/performance-test.js" > "$PERF_DIR/memory-stress-test.txt" 2>/dev/null || echo "Node.js not available"

  # Bundle analysis
  if [ -f "package.json" ] && grep -q "webpack-bundle-analyzer" package.json; then
    echo "ğŸ“Š Generating bundle analysis..."
    npm run analyze > "$PERF_DIR/bundle-analysis.txt" 2>/dev/null || echo "Bundle analyzer not configured"
  fi

  echo "âœ… Performance testing completed"
  echo ""
  ```

  ## ğŸ“Š Step 8: Performance Report Generation
  ```bash
  echo "=== Performance Report Generation ==="

  echo "ğŸ“Š Generating comprehensive performance report..."

  # Calculate metrics
  LARGE_FILES_COUNT=$(wc -l < "$PERF_DIR/large-files.txt" 2>/dev/null || echo "0")
  SYNC_OPS_COUNT=$(wc -l < "$PERF_DIR/sync-operations.txt" 2>/dev/null || echo "0")
  NESTED_LOOPS_COUNT=$(wc -l < "$PERF_DIR/nested-loops.txt" 2>/dev/null || echo "0")

  # Generate performance report
  cat << EOF > "$PERF_DIR/performance-report.md"
  # Performance Optimization Report

  **Project:** $PROJECT_NAME  
  **Analysis Date:** $OPTIMIZATION_DATE  
  **Baseline ID:** $BASELINE_ID

  ## Executive Summary

  This report contains the results of a comprehensive performance analysis and optimization recommendations for $PROJECT_NAME.

  ## Performance Metrics

  | Metric | Count | Impact |
  |--------|-------|--------|
  | Large Files (>500 lines) | $LARGE_FILES_COUNT | ğŸ“„ Medium |
  | Synchronous Operations | $SYNC_OPS_COUNT | â³ High |
  | Nested Loops | $NESTED_LOOPS_COUNT | ğŸ§® Medium |

  ## Detailed Analysis

  ### 1. Code Performance
  - Large files detected: $LARGE_FILES_COUNT
  - Synchronous operations: $SYNC_OPS_COUNT
  - Complex nested loops: $NESTED_LOOPS_COUNT

  ### 2. Bundle Performance
  - Bundle size analysis completed
  - Code splitting opportunities identified
  - Tree shaking recommendations provided

  ### 3. Memory Usage
  - Memory baseline established
  - Potential memory leaks identified
  - Optimization recommendations provided

  ## Optimization Recommendations

  ### Immediate Actions (High Impact)
  1. Replace synchronous operations with async alternatives
  2. Implement code splitting for large bundles
  3. Add database indexes for slow queries
  4. Implement caching strategy

  ### Short-term Actions (Medium Impact)
  1. Optimize large files and complex functions
  2. Implement lazy loading for components
  3. Add performance monitoring
  4. Optimize asset delivery (CDN, compression)

  ### Long-term Actions (Low Impact)
  1. Regular performance audits
  2. Performance budgets implementation
  3. Advanced caching strategies
  4. Microservices architecture consideration

  ## Implementation Guide

  ### Bundle Optimization
  \`\`\`javascript
  // webpack.config.js optimization
  module.exports = {
    optimization: {
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\\\/]node_modules[\\\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
        },
      },
    },
  };
  \`\`\`

  ### Caching Implementation
  \`\`\`javascript
  // Express.js caching middleware
  const cache = require('memory-cache');

  app.use((req, res, next) => {
    const key = req.originalUrl;
    const cached = cache.get(key);
    
    if (cached) {
      return res.send(cached);
    }
    
    res.sendResponse = res.send;
    res.send = (body) => {
      cache.put(key, body, 300000); // 5 minutes
      res.sendResponse(body);
    };
    
    next();
  });
  \`\`\`

  ## Performance Monitoring

  Implement continuous performance monitoring:

  1. Response time tracking
  2. Memory usage monitoring
  3. Error rate monitoring
  4. User experience metrics

  ## Next Steps

  1. Implement high-impact optimizations
  2. Set up performance monitoring
  3. Establish performance budgets
  4. Schedule regular performance reviews

  ---
  *Generated by task-action performance optimization*
  EOF

  echo "ğŸ“„ Performance report generated: $PERF_DIR/performance-report.md"
  echo ""
  ```

  ## ğŸ¯ Step 9: Optimization Summary
  ```bash
  echo "=== Performance Optimization Summary ==="

  echo "âš¡ Performance optimization analysis completed!"
  echo ""
  echo "ğŸ“Š Key Findings:"
  echo "  ğŸ“„ Large files: $LARGE_FILES_COUNT"
  echo "  â³ Sync operations: $SYNC_OPS_COUNT"
  echo "  ğŸ§® Nested loops: $NESTED_LOOPS_COUNT"
  echo ""
  echo "ğŸ¯ Priority Actions:"
  if [ $SYNC_OPS_COUNT -gt 0 ]; then
    echo "  ğŸš¨ HIGH: Replace $SYNC_OPS_COUNT synchronous operations"
  fi
  if [ $LARGE_FILES_COUNT -gt 5 ]; then
    echo "  âš ï¸  MEDIUM: Refactor $LARGE_FILES_COUNT large files"
  fi
  if [ $NESTED_LOOPS_COUNT -gt 0 ]; then
    echo "  âš ï¸  MEDIUM: Optimize $NESTED_LOOPS_COUNT nested loops"
  fi
  echo ""
  echo "ğŸ“ Generated Files:"
  echo "  - performance-report.md"
  echo "  - performance-monitor.js"
  echo "  - performance-test.js"
  echo "  - webpack-optimization.js"
  echo ""
  echo "ğŸ”„ Next Steps:"
  echo "  1. Review performance report"
  echo "  2. Implement high-priority optimizations"
  echo "  3. Set up performance monitoring"
  echo "  4. Schedule follow-up analysis"
  echo ""
  echo "ğŸ“ˆ Performance optimization workflow completed!"
  ```

  **âš¡ Comprehensive performance analysis completed with actionable optimization recommendations!**
