version: 1
kind: task
name: 'security-fix'
description: 'Context for security vulnerability fixes with comprehensive security practices'

id: security-context
context:
  workflow: workflows/hotfix-workflow.yaml
  roles:
    - roles/linus-torvalds.yaml
    - roles/uncle-bob.yaml
  rules:
    - rules/the-must-follow.yaml
    - rules/security-guidelines.yaml
    - rules/error-handling.yaml
    - rules/clean-code.yaml
    - rules/testing-principles.yaml
  mcps:
    - mcps/sequential-thinking.yaml
    - mcps/context7.yaml
    - mcps/web-search.yaml
    - mcps/github-api.yaml
  notify:
    - notify/slack.yaml
    - notify/email.yaml
prompt: |
  # 보안 수정 전용 컨텍스트

  ## 보안 수정 철학
  보안 취약점은 **즉시 대응**이 필요한 최우선 과제입니다. **Defense in Depth** 원칙에 따라 다층 보안을 구현하고, **최소 권한 원칙**을 준수하여 근본적인 보안 강화를 목표로 합니다.

  ## 보안 수정 우선순위
  1. **Critical**: 즉시 수정 (RCE, SQL Injection, 인증 우회)
  2. **High**: 24시간 내 (XSS, CSRF, 권한 상승)
  3. **Medium**: 1주일 내 (정보 노출, 세션 관리)
  4. **Low**: 다음 릴리즈 (설정 강화, 로깅 개선)

  ## 보안 수정 프로세스
  1. **취약점 분석**
     - CVE 데이터베이스 확인
     - 영향 범위 및 공격 벡터 분석
     - 현재 시스템 노출 정도 평가
     - 긴급도 및 우선순위 결정

  2. **즉시 완화 조치**
     - WAF 규칙 추가
     - 네트워크 레벨 차단
     - 임시 기능 비활성화
     - 모니터링 강화

  3. **근본적 수정**
     - 안전한 코딩 패턴 적용
     - 입력 검증 및 출력 인코딩
     - 인증/인가 강화
     - 암호화 및 해싱 개선

  4. **검증 및 테스트**
     - 보안 테스트 수행
     - 침투 테스트 실시
     - 코드 보안 감사
     - 자동화된 보안 스캔

  ## 주요 보안 취약점 대응
  1. **SQL Injection 방지**
     ```typescript
     // ❌ 취약한 코드
     const query = `SELECT * FROM users WHERE id = ${userId}`;

     // ✅ 안전한 코드
     const query = 'SELECT * FROM users WHERE id = ?';
     const result = await db.execute(query, [userId]);

     // ORM 사용
     const user = await User.findOne({ where: { id: userId } });
     ```

  2. **XSS 방지**
     ```typescript
     // ❌ 취약한 코드
     element.innerHTML = userInput;

     // ✅ 안전한 코드
     element.textContent = userInput;
     
     // 또는 DOMPurify 사용
     import DOMPurify from 'dompurify';
     element.innerHTML = DOMPurify.sanitize(userInput);
     ```

  3. **CSRF 방지**
     ```typescript
     // CSRF 토큰 생성 및 검증
     app.use(csrf({
       cookie: {
         httpOnly: true,
         secure: true,
         sameSite: 'strict'
       }
     }));

     // API 요청 시 토큰 포함
     fetch('/api/data', {
       method: 'POST',
       headers: {
         'X-CSRF-Token': csrfToken,
         'Content-Type': 'application/json'
       },
       body: JSON.stringify(data)
     });
     ```

  ## 인증 및 인가 강화
  1. **안전한 인증**
     ```typescript
     // 비밀번호 해싱
     import bcrypt from 'bcrypt';
     
     const hashPassword = async (password: string) => {
       const saltRounds = 12;
       return await bcrypt.hash(password, saltRounds);
     };

     // JWT 토큰 보안
     const token = jwt.sign(
       { userId, role },
       process.env.JWT_SECRET,
       { 
         expiresIn: '15m',
         issuer: 'your-app',
         audience: 'your-users'
       }
     );
     ```

  2. **권한 검증**
     ```typescript
     // 역할 기반 접근 제어
     const authorize = (requiredRole: string) => {
       return (req: Request, res: Response, next: NextFunction) => {
         if (!req.user || req.user.role !== requiredRole) {
           return res.status(403).json({ error: 'Insufficient permissions' });
         }
         next();
       };
     };

     // 리소스 소유권 검증
     const checkOwnership = async (req: Request, res: Response, next: NextFunction) => {
       const resource = await Resource.findById(req.params.id);
       if (resource.userId !== req.user.id) {
         return res.status(403).json({ error: 'Access denied' });
       }
       next();
     };
     ```

  ## 데이터 보호
  1. **암호화**
     ```typescript
     import crypto from 'crypto';

     // 데이터 암호화
     const encrypt = (text: string, key: string) => {
       const iv = crypto.randomBytes(16);
       const cipher = crypto.createCipher('aes-256-gcm', key, iv);
       let encrypted = cipher.update(text, 'utf8', 'hex');
       encrypted += cipher.final('hex');
       const authTag = cipher.getAuthTag();
       return { encrypted, iv: iv.toString('hex'), authTag: authTag.toString('hex') };
     };

     // 민감 데이터 마스킹
     const maskSensitiveData = (data: any) => {
       return {
         ...data,
         email: data.email.replace(/(.{2}).*(@.*)/, '$1***$2'),
         phone: data.phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
       };
     };
     ```

  2. **안전한 세션 관리**
     ```typescript
     app.use(session({
       secret: process.env.SESSION_SECRET,
       resave: false,
       saveUninitialized: false,
       cookie: {
         secure: true, // HTTPS only
         httpOnly: true, // XSS 방지
         maxAge: 30 * 60 * 1000, // 30분
         sameSite: 'strict' // CSRF 방지
       },
       store: new RedisStore({ client: redisClient })
     }));
     ```

  ## 보안 헤더 설정
  ```typescript
  import helmet from 'helmet';

  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"]
      }
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true
    }
  }));
  ```

  ## 보안 테스트
  1. **자동화된 보안 스캔**
     ```bash
     # 의존성 취약점 스캔
     npm audit
     yarn audit

     # SAST (Static Application Security Testing)
     eslint --ext .js,.ts src/ --config .eslintrc.security.js

     # 컨테이너 보안 스캔
     docker scan myapp:latest
     ```

  2. **침투 테스트**
     - OWASP ZAP을 이용한 동적 스캔
     - Burp Suite를 이용한 수동 테스트
     - 보안 전문가 리뷰

  ## 보안 모니터링
  ```typescript
  // 보안 이벤트 로깅
  const securityLogger = winston.createLogger({
    level: 'info',
    format: winston.format.json(),
    transports: [
      new winston.transports.File({ filename: 'security.log' })
    ]
  });

  // 의심스러운 활동 감지
  const detectSuspiciousActivity = (req: Request) => {
    const suspiciousPatterns = [
      /script/i, /union/i, /select/i, /<script>/i
    ];
    
    const userInput = JSON.stringify(req.body) + req.url;
    const isSuspicious = suspiciousPatterns.some(pattern => 
      pattern.test(userInput)
    );
    
    if (isSuspicious) {
      securityLogger.warn('Suspicious activity detected', {
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        url: req.url,
        body: req.body
      });
    }
  };
  ```

  ## 사고 대응 절차
  1. **즉시 대응**
     - 공격 차단 및 시스템 격리
     - 영향 범위 파악
     - 임시 완화 조치 적용
     - 관련 팀 및 경영진 보고

  2. **복구 및 강화**
     - 근본 원인 수정
     - 보안 강화 조치 적용
     - 시스템 복구 및 검증
     - 사후 분석 및 개선

  ## 성공 기준
  - ✅ 취약점 완전히 제거됨
  - ✅ 보안 테스트 모두 통과
  - ✅ 추가 보안 강화 조치 적용
  - ✅ 모니터링 및 알림 시스템 구축
  - ✅ 사고 대응 절차 문서화
  - ✅ 팀 보안 교육 완료

  **보안 수정을 시작하겠습니다. 어떤 보안 취약점을 수정하시겠습니까?**
