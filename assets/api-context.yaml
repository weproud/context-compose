version: 1
kind: task
name: 'api-development'
description: 'Context for API development with RESTful design and comprehensive documentation'

id: api-context
context:
  workflow: workflows/feature-workflow.yaml
  roles:
    - roles/dan-abramov.yaml
    - roles/martin-fowler.yaml
  rules:
    - rules/the-must-follow.yaml
    - rules/api-design.yaml
    - rules/clean-code.yaml
    - rules/security-guidelines.yaml
    - rules/testing-principles.yaml
    - rules/error-handling.yaml
    - rules/documentation-standards.yaml
  mcps:
    - mcps/sequential-thinking.yaml
    - mcps/context7.yaml
    - mcps/web-search.yaml
  notify:
    - notify/slack.yaml
prompt: |
  # API Development Context

  ## API Development Philosophy
  APIs prioritize **Developer Experience (DX)** and provide interfaces with **consistency**, **predictability**, and **scalability**. Follow **RESTful principles** and document according to **OpenAPI standards**.

  ## API Design Principles
  1. **RESTful Design**: Semantic use of HTTP methods and status codes
  2. **Consistency**: Consistent naming conventions, response formats, and error handling
  3. **Version Management**: Versioning strategy considering backward compatibility
  4. **Security First**: Default application of authentication, authorization, and data protection
  5. **Performance Optimization**: Efficient data transmission and caching strategies

  ## API Development Process
  1. **API Design**
     - Resource modeling and endpoint definition
     - Request/response schema design
     - Error handling and status code definition
     - Authentication/authorization method determination

  2. **OpenAPI Specification Writing**
     - Write Swagger/OpenAPI 3.0 specifications
     - Include schema definitions and examples
     - Specify authentication methods and security requirements
     - Configure automatic documentation generation

  3. **Implementation & Testing**
     - Implement controller and service layers
     - Input validation and data transformation
     - Write unit/integration/E2E tests
     - Synchronize API documentation with implementation

  ## RESTful API Design
  1. **Resource-Centric Design**
     ```
     GET    /api/v1/users           # Retrieve user list
     GET    /api/v1/users/{id}      # Retrieve specific user
     POST   /api/v1/users           # Create new user
     PUT    /api/v1/users/{id}      # Full user update
     PATCH  /api/v1/users/{id}      # Partial user update
     DELETE /api/v1/users/{id}      # Delete user

     # Nested resources
     GET    /api/v1/users/{id}/orders    # User's order list
     POST   /api/v1/users/{id}/orders    # Create new order for user
     ```

  2. **HTTP Status Code Usage**
     ```typescript
     // Success responses
     200 OK          // Successful retrieval, update
     201 Created     // Successful creation
     204 No Content  // Successful deletion

     // Client errors
     400 Bad Request     // Invalid request
     401 Unauthorized    // Authentication required
     403 Forbidden       // No permission
     404 Not Found       // Resource not found
     409 Conflict        // Conflict (duplicate creation, etc.)
     422 Unprocessable Entity // Validation failure

     // Server errors
     500 Internal Server Error // Internal server error
     503 Service Unavailable   // Service unavailable
     ```

  ## API Implementation Examples
  1. **Controller Implementation**
     ```typescript
     @Controller('/api/v1/users')
     @ApiTags('Users')
     export class UserController {
       constructor(private userService: UserService) {}

       @Get()
       @ApiOperation({ summary: 'Retrieve user list' })
       @ApiQuery({ name: 'page', required: false, type: Number })
       @ApiQuery({ name: 'limit', required: false, type: Number })
       async getUsers(
         @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
         @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number
       ): Promise<PaginatedResponse<User>> {
         return this.userService.findAll({ page, limit });
       }

       @Post()
       @ApiOperation({ summary: 'Create new user' })
       @ApiBody({ type: CreateUserDto })
       @ApiResponse({ status: 201, type: User })
       async createUser(@Body() createUserDto: CreateUserDto): Promise<User> {
         return this.userService.create(createUserDto);
       }

       @Get(':id')
       @ApiOperation({ summary: 'Retrieve user' })
       @ApiParam({ name: 'id', type: 'string' })
       async getUser(@Param('id', ParseUUIDPipe) id: string): Promise<User> {
         const user = await this.userService.findById(id);
         if (!user) {
           throw new NotFoundException('User not found');
         }
         return user;
       }
     }
     ```

  2. **DTO & Validation**
     ```typescript
     export class CreateUserDto {
       @ApiProperty({ example: 'john@example.com' })
       @IsEmail()
       @IsNotEmpty()
       email: string;

       @ApiProperty({ example: 'John Doe' })
       @IsString()
       @Length(2, 50)
       name: string;

       @ApiProperty({ example: 'SecurePassword123!' })
       @IsString()
       @MinLength(8)
       @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
       password: string;
     }

     export class UpdateUserDto extends PartialType(CreateUserDto) {
       @ApiPropertyOptional()
       @IsOptional()
       @IsString()
       name?: string;
     }
     ```

  ## Response Format Standardization
  ```typescript
  // Success response
  interface ApiResponse<T> {
    success: true;
    data: T;
    message?: string;
    meta?: {
      timestamp: string;
      requestId: string;
    };
  }

  // Pagination response
  interface PaginatedResponse<T> extends ApiResponse<T[]> {
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
  }

  // Error response
  interface ErrorResponse {
    success: false;
    error: {
      code: string;
      message: string;
      details?: any;
    };
    meta: {
      timestamp: string;
      requestId: string;
    };
  }
  ```

  ## Authentication & Security
  1. **JWT Authentication**
     ```typescript
     @Injectable()
     export class JwtAuthGuard implements CanActivate {
       constructor(private jwtService: JwtService) {}

       canActivate(context: ExecutionContext): boolean {
         const request = context.switchToHttp().getRequest();
         const token = this.extractTokenFromHeader(request);

         if (!token) {
           throw new UnauthorizedException('Token not found');
         }

         try {
           const payload = this.jwtService.verify(token);
           request.user = payload;
           return true;
         } catch {
           throw new UnauthorizedException('Invalid token');
         }
       }
     }
     ```

  2. **Role-Based Access Control**
     ```typescript
     @Injectable()
     export class RolesGuard implements CanActivate {
       constructor(private reflector: Reflector) {}

       canActivate(context: ExecutionContext): boolean {
         const requiredRoles = this.reflector.getAllAndOverride<Role[]>(
           ROLES_KEY,
           [context.getHandler(), context.getClass()]
         );

         if (!requiredRoles) return true;

         const { user } = context.switchToHttp().getRequest();
         return requiredRoles.some((role) => user.roles?.includes(role));
       }
     }

     // Usage
     @Roles(Role.Admin)
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Delete(':id')
     async deleteUser(@Param('id') id: string) {
       return this.userService.delete(id);
     }
     ```

  ## API Testing
  1. **Unit Testing**
     ```typescript
     describe('UserController', () => {
       let controller: UserController;
       let service: UserService;

       beforeEach(async () => {
         const module = await Test.createTestingModule({
           controllers: [UserController],
           providers: [
             {
               provide: UserService,
               useValue: {
                 findAll: jest.fn(),
                 create: jest.fn(),
                 findById: jest.fn(),
               },
             },
           ],
         }).compile();

         controller = module.get<UserController>(UserController);
         service = module.get<UserService>(UserService);
       });

       it('should return paginated users', async () => {
         const result = { data: [], pagination: {} };
         jest.spyOn(service, 'findAll').mockResolvedValue(result);

         expect(await controller.getUsers(1, 10)).toBe(result);
       });
     });
     ```

  2. **Integration Testing**
     ```typescript
     describe('Users API', () => {
       let app: INestApplication;

       beforeAll(async () => {
         const moduleFixture = await Test.createTestingModule({
           imports: [AppModule],
         }).compile();

         app = moduleFixture.createNestApplication();
         await app.init();
       });

       it('/users (GET)', () => {
         return request(app.getHttpServer())
           .get('/api/v1/users')
           .expect(200)
           .expect((res) => {
             expect(res.body.success).toBe(true);
             expect(Array.isArray(res.body.data)).toBe(true);
           });
       });

       it('/users (POST)', () => {
         return request(app.getHttpServer())
           .post('/api/v1/users')
           .send({
             email: 'test@example.com',
             name: 'Test User',
             password: 'SecurePassword123!'
           })
           .expect(201);
       });
     });
     ```

  ## API Documentation
  ```typescript
  // Swagger configuration in main.ts
  const config = new DocumentBuilder()
    .setTitle('User Management API')
    .setDescription('RESTful API for user management')
    .setVersion('1.0')
    .addBearerAuth()
    .addTag('Users', 'User management')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);
  ```

  ## Success Criteria
  - ✅ RESTful principles compliance
  - ✅ Consistent response format and error handling
  - ✅ Comprehensive input validation
  - ✅ Proper authentication/authorization implementation
  - ✅ Complete OpenAPI documentation
  - ✅ High test coverage (90%+)
  - ✅ Performance requirements met

  **Ready to start API development. What API would you like to develop?**
