version: 1
kind: task
name: 'api-development'
description: 'Context for API development with RESTful design and comprehensive documentation'

id: api-context
context:
  workflow: workflows/feature-workflow.yaml
  roles:
    - roles/dan-abramov.yaml
    - roles/martin-fowler.yaml
  rules:
    - rules/the-must-follow.yaml
    - rules/api-design.yaml
    - rules/clean-code.yaml
    - rules/security-guidelines.yaml
    - rules/testing-principles.yaml
    - rules/error-handling.yaml
    - rules/documentation-standards.yaml
  mcps:
    - mcps/sequential-thinking.yaml
    - mcps/context7.yaml
    - mcps/web-search.yaml
  notify:
    - notify/slack.yaml
prompt: |
  # API 개발 전용 컨텍스트

  ## API 개발 철학
  API는 **개발자 경험(DX)**을 최우선으로 하며, **일관성**, **예측 가능성**, **확장성**을 갖춘 인터페이스를 제공합니다. **RESTful 원칙**을 준수하고 **OpenAPI 표준**을 따라 문서화합니다.

  ## API 설계 원칙
  1. **RESTful 설계**: HTTP 메서드와 상태 코드의 의미론적 사용
  2. **일관성**: 명명 규칙, 응답 형식, 에러 처리의 일관성
  3. **버전 관리**: 하위 호환성을 고려한 버전 전략
  4. **보안 우선**: 인증, 인가, 데이터 보호 기본 적용
  5. **성능 최적화**: 효율적인 데이터 전송과 캐싱 전략

  ## API 개발 프로세스
  1. **API 설계**
     - 리소스 모델링 및 엔드포인트 정의
     - 요청/응답 스키마 설계
     - 에러 처리 및 상태 코드 정의
     - 인증/인가 방식 결정

  2. **OpenAPI 명세서 작성**
     - Swagger/OpenAPI 3.0 스펙 작성
     - 스키마 정의 및 예제 포함
     - 인증 방식 및 보안 요구사항 명시
     - 자동 문서 생성 설정

  3. **구현 및 테스트**
     - 컨트롤러 및 서비스 레이어 구현
     - 입력 검증 및 데이터 변환
     - 단위/통합/E2E 테스트 작성
     - API 문서와 구현 동기화

  ## RESTful API 설계
  1. **리소스 중심 설계**
     ```
     GET    /api/v1/users           # 사용자 목록 조회
     GET    /api/v1/users/{id}      # 특정 사용자 조회
     POST   /api/v1/users           # 새 사용자 생성
     PUT    /api/v1/users/{id}      # 사용자 전체 업데이트
     PATCH  /api/v1/users/{id}      # 사용자 부분 업데이트
     DELETE /api/v1/users/{id}      # 사용자 삭제

     # 중첩 리소스
     GET    /api/v1/users/{id}/orders    # 사용자의 주문 목록
     POST   /api/v1/users/{id}/orders    # 사용자의 새 주문 생성
     ```

  2. **HTTP 상태 코드 활용**
     ```typescript
     // 성공 응답
     200 OK          // 조회, 업데이트 성공
     201 Created     // 생성 성공
     204 No Content  // 삭제 성공

     // 클라이언트 에러
     400 Bad Request     // 잘못된 요청
     401 Unauthorized    // 인증 필요
     403 Forbidden       // 권한 없음
     404 Not Found       // 리소스 없음
     409 Conflict        // 충돌 (중복 생성 등)
     422 Unprocessable Entity // 검증 실패

     // 서버 에러
     500 Internal Server Error // 서버 내부 오류
     503 Service Unavailable   // 서비스 이용 불가
     ```

  ## API 구현 예제
  1. **컨트롤러 구현**
     ```typescript
     @Controller('/api/v1/users')
     @ApiTags('Users')
     export class UserController {
       constructor(private userService: UserService) {}

       @Get()
       @ApiOperation({ summary: '사용자 목록 조회' })
       @ApiQuery({ name: 'page', required: false, type: Number })
       @ApiQuery({ name: 'limit', required: false, type: Number })
       async getUsers(
         @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
         @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number
       ): Promise<PaginatedResponse<User>> {
         return this.userService.findAll({ page, limit });
       }

       @Post()
       @ApiOperation({ summary: '새 사용자 생성' })
       @ApiBody({ type: CreateUserDto })
       @ApiResponse({ status: 201, type: User })
       async createUser(@Body() createUserDto: CreateUserDto): Promise<User> {
         return this.userService.create(createUserDto);
       }

       @Get(':id')
       @ApiOperation({ summary: '사용자 조회' })
       @ApiParam({ name: 'id', type: 'string' })
       async getUser(@Param('id', ParseUUIDPipe) id: string): Promise<User> {
         const user = await this.userService.findById(id);
         if (!user) {
           throw new NotFoundException('User not found');
         }
         return user;
       }
     }
     ```

  2. **DTO 및 검증**
     ```typescript
     export class CreateUserDto {
       @ApiProperty({ example: 'john@example.com' })
       @IsEmail()
       @IsNotEmpty()
       email: string;

       @ApiProperty({ example: 'John Doe' })
       @IsString()
       @Length(2, 50)
       name: string;

       @ApiProperty({ example: 'SecurePassword123!' })
       @IsString()
       @MinLength(8)
       @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
       password: string;
     }

     export class UpdateUserDto extends PartialType(CreateUserDto) {
       @ApiPropertyOptional()
       @IsOptional()
       @IsString()
       name?: string;
     }
     ```

  ## 응답 형식 표준화
  ```typescript
  // 성공 응답
  interface ApiResponse<T> {
    success: true;
    data: T;
    message?: string;
    meta?: {
      timestamp: string;
      requestId: string;
    };
  }

  // 페이지네이션 응답
  interface PaginatedResponse<T> extends ApiResponse<T[]> {
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
  }

  // 에러 응답
  interface ErrorResponse {
    success: false;
    error: {
      code: string;
      message: string;
      details?: any;
    };
    meta: {
      timestamp: string;
      requestId: string;
    };
  }
  ```

  ## 인증 및 보안
  1. **JWT 인증**
     ```typescript
     @Injectable()
     export class JwtAuthGuard implements CanActivate {
       constructor(private jwtService: JwtService) {}

       canActivate(context: ExecutionContext): boolean {
         const request = context.switchToHttp().getRequest();
         const token = this.extractTokenFromHeader(request);
         
         if (!token) {
           throw new UnauthorizedException('Token not found');
         }

         try {
           const payload = this.jwtService.verify(token);
           request.user = payload;
           return true;
         } catch {
           throw new UnauthorizedException('Invalid token');
         }
       }
     }
     ```

  2. **역할 기반 접근 제어**
     ```typescript
     @Injectable()
     export class RolesGuard implements CanActivate {
       constructor(private reflector: Reflector) {}

       canActivate(context: ExecutionContext): boolean {
         const requiredRoles = this.reflector.getAllAndOverride<Role[]>(
           ROLES_KEY,
           [context.getHandler(), context.getClass()]
         );

         if (!requiredRoles) return true;

         const { user } = context.switchToHttp().getRequest();
         return requiredRoles.some((role) => user.roles?.includes(role));
       }
     }

     // 사용법
     @Roles(Role.Admin)
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Delete(':id')
     async deleteUser(@Param('id') id: string) {
       return this.userService.delete(id);
     }
     ```

  ## API 테스트
  1. **단위 테스트**
     ```typescript
     describe('UserController', () => {
       let controller: UserController;
       let service: UserService;

       beforeEach(async () => {
         const module = await Test.createTestingModule({
           controllers: [UserController],
           providers: [
             {
               provide: UserService,
               useValue: {
                 findAll: jest.fn(),
                 create: jest.fn(),
                 findById: jest.fn(),
               },
             },
           ],
         }).compile();

         controller = module.get<UserController>(UserController);
         service = module.get<UserService>(UserService);
       });

       it('should return paginated users', async () => {
         const result = { data: [], pagination: {} };
         jest.spyOn(service, 'findAll').mockResolvedValue(result);

         expect(await controller.getUsers(1, 10)).toBe(result);
       });
     });
     ```

  2. **통합 테스트**
     ```typescript
     describe('Users API', () => {
       let app: INestApplication;

       beforeAll(async () => {
         const moduleFixture = await Test.createTestingModule({
           imports: [AppModule],
         }).compile();

         app = moduleFixture.createNestApplication();
         await app.init();
       });

       it('/users (GET)', () => {
         return request(app.getHttpServer())
           .get('/api/v1/users')
           .expect(200)
           .expect((res) => {
             expect(res.body.success).toBe(true);
             expect(Array.isArray(res.body.data)).toBe(true);
           });
       });

       it('/users (POST)', () => {
         return request(app.getHttpServer())
           .post('/api/v1/users')
           .send({
             email: 'test@example.com',
             name: 'Test User',
             password: 'SecurePassword123!'
           })
           .expect(201);
       });
     });
     ```

  ## API 문서화
  ```typescript
  // main.ts에서 Swagger 설정
  const config = new DocumentBuilder()
    .setTitle('User Management API')
    .setDescription('사용자 관리를 위한 RESTful API')
    .setVersion('1.0')
    .addBearerAuth()
    .addTag('Users', '사용자 관리')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);
  ```

  ## 성공 기준
  - ✅ RESTful 원칙 준수
  - ✅ 일관된 응답 형식 및 에러 처리
  - ✅ 포괄적인 입력 검증
  - ✅ 적절한 인증/인가 구현
  - ✅ 완전한 OpenAPI 문서화
  - ✅ 높은 테스트 커버리지 (90% 이상)
  - ✅ 성능 요구사항 충족

  **API 개발을 시작하겠습니다. 어떤 API를 개발하시겠습니까?**
